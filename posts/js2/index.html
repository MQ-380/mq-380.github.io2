<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>JavaScript精进之路 — 异步的实现（上） | Subaru</title><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="JavaScript精进之路 — 异步的实现（上）" /><meta name="author" content="Subaru" /><meta property="og:locale" content="en_US" /><meta name="description" content="要帶著問題學,活學活用,學用結合,急用先學,立竿見影,在「用」字上狠下功夫。 — 林副主席" /><meta property="og:description" content="要帶著問題學,活學活用,學用結合,急用先學,立竿見影,在「用」字上狠下功夫。 — 林副主席" /><link rel="canonical" href="https://mq-380.github.io/posts/js2/" /><meta property="og:url" content="https://mq-380.github.io/posts/js2/" /><meta property="og:site_name" content="Subaru" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2017-08-19T00:03:36+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="JavaScript精进之路 — 异步的实现（上）" /><meta name="twitter:site" content="@MQ380" /><meta name="twitter:creator" content="@Subaru" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"要帶著問題學,活學活用,學用結合,急用先學,立竿見影,在「用」字上狠下功夫。 — 林副主席","dateModified":"2017-08-19T00:03:36+08:00","datePublished":"2017-08-19T00:03:36+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mq-380.github.io/posts/js2/"},"url":"https://mq-380.github.io/posts/js2/","author":{"@type":"Person","name":"Subaru"},"headline":"JavaScript精进之路 — 异步的实现（上）","@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/main.css"><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/popper.js@1.15.0/dist/umd/popper.min.js" integrity="sha256-fTuUgtT7O2rqoImwjrhDgbXTKUwyxxujIMRIK7TbuNU=" crossorigin> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script> window.jQuery || document.write('<script src="/assets/lib/jquery-3.4.1.min.js"><\/script>'); </script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.15.0/dist/umd/popper.min.js" integrity="sha256-fTuUgtT7O2rqoImwjrhDgbXTKUwyxxujIMRIK7TbuNU=" crossorigin="anonymous" async></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha256-5+02zu5UULQkO7w1GIr6vftCgMfFdZcAHeDtFnKZsBs=" crossorigin="anonymous" async></script> <script src="/assets/js/dist/commons.js" async></script> <script src="/assets/js/dist/timeago.min.js" async></script><link rel="preload" as="style" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/syntax.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/syntax.css"><link rel="preload" as="style" href="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.css"><link rel="preload" as="script" href="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.js"><link rel="stylesheet" href="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.css" /> <script src="/assets/lib/bootstrap-toc-1.0.1/bootstrap-toc.min.js" async></script> <script src="/assets/js/dist/toc.min.js" async></script> <script src="/assets/js/dist/tooltip-loader.min.js" async></script> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/poe.jpg" alt="avatar"> </a></div><div class="profile-text mt-3"><div id="site-title"> <a href="/">Subaru</a></div><div id="site-subtitle" class="font-italic">FE Engnieer</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-3 mr-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-3 mr-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-3 mr-3 unloaded"></i> <span>ARCHIVES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-3 mr-3 unloaded"></i> <span>ABOUT</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" light-mode-invisible></i> <i class="mode-toggle fas fa-moon" dark-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isDarkPrefer) { this.setDark(); } } else { if (this.isDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isDarkPrefer) { self.setDark(); } } else { if (self.isDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isDarkPrefer() { return this.sysDarkPrefers.matches; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if ((this.mode == null && this.isDarkPrefer) || this.mode == ModeToggle.DARK_MODE) { this.setLight(); } else { /* light mode or default-light */ this.setDark(); } } } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/mq-380" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/MQ380" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href="javascript:window.open('mailto:' + ['shmao288','gmail.com'].join('@'))"> <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" target="_blank"> <i class="fas fa-rss"></i> </a></div></div><div id="main-wrapper"> <!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>JavaScript精进之路 — 异步的实现（上）</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main"> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="progress" style=""><div class="progress-bar" id="progress" role="progressbar" style="width: 0%" aria-valuenow="25" aria-valuemin="0" aria-valuemax="100"></div></div><div class="row" id='article_wrapper'><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>JavaScript精进之路 — 异步的实现（上）</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago" data-toggle="tooltip" data-placement="bottom" title="Sat, Aug 19, 2017, 12:03 AM +0800"> Aug 19, 2017 <i class="unloaded">2017-08-19T00:03:36+08:00</i> </span> on <a href='/categories/%E6%8A%80%E6%9C%AF/'>技术</a></div></div><div class="post-content" id='post-content'><blockquote><p>要帶著問題學,活學活用,學用結合,急用先學,立竿見影,在「用」字上狠下功夫。<br /> — 林副主席</p></blockquote><p>题词是林副主席的语录，很有感触，特记于此。</p><p>废话少说。 这是这个专题的第二部分内容，异步。主要总结了《你不知道的JavaScript（中卷）》中有关于异步的内容。显然一下子写完三个部分的内容不太可能，下篇会在不久之后放出。 由于前人之述备矣，所以有些地方会引用它山之石，它山之石可以攻玉嘛。 🙈</p><h2 id="什么是异步">什么是异步</h2><p>首先明确，JavaScript是一种单线程语言，不会出现多线程。</p><ol><li><p>【异步的核心】程序中现在运行部分和将来运行部分的关系就是异步编程的核心。简单来讲，如果程序中出现了一部分要在现在运行（顺序同步执行），一部分要在将来运行（可能是设置了timeout也可能是一个ajax的异步调用后执行的函数），那么两者之间的关系的构建就构成了异步编程。</p></li><li><p>【事件循环】相当于一个永远执行的while(true)循环，循环的每一轮称为一个tick。对于每个tick而言，如果队列中有等待事件，那么从队列中拿下这个事件执行。队列中事件就是注册的异步调用函数。 由于事件循环的原因，setTimeout只是在timeout的时间后将函数注册到事件循环中，因为有被其他任务阻塞的可能，所以其时间不一定准确。setInterval同理可得。 setTimeout(…,0)可以进行异步调动，将函数放在事件队列循环的末尾，是一种hack的方法。 具体可以参阅以下blog：<a href="http://www.jeffjade.com/2016/01/10/2016-01-10-javascript-setInterval/">你所不知道的setInterval | 晚晴幽草轩</a></p></li><li><p>【任务】Promise的then是基于任务的。任务和事件循环的区别，可以理解为任务代表的异步函数可以插队进入当前事件之后。所以从理论上来说，任务循环（job loop）可能导致无限循环（一个任务添加另一个不需要排队的任务，例如Promise中then的无限连接）使得无法进入到下一个tick中。</p></li></ol><p>EX 事件循环和任务的感性认识</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre> <span class="p">(</span><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">)},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">10000</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nx">i</span> <span class="o">==</span> <span class="mi">9999</span> <span class="o">&amp;&amp;</span> <span class="nx">resolve</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">})()</span>
</pre></table></code></div></div><p>输出是 1 2 3 5 4 而非 1 2 3 4 5 这就说明了Promise决议之后，先执行了then的这个任务（job），这个then没有进入事件循环中排队，因为如果排队，应该会在setTimeout这个先注册的function之后调用。所以then的任务队列的优先级高于事件循环。并且磁力还说明了Promise的决议过程是同步执行的。</p><p>具体的原理说明： https://github.com/creeperyang/blog/issues/21</p><ol><li>【异步交互协调】有时会由于两个ajax调用的先后顺序（或者其他操作的先后顺序）的原因会导致运行结果的不同，为了控制进程的执行，有两种控制的模式和两种简单的方式： 首先是门：这个可以控制两个函数都完成之后才进行下一步工作，条件控制条件为if(a &amp;&amp; b) 第二种是竞态，也可称为门闩。就是两个函数只有一个能够被调用，另一个会被忽略，其控制条件是设置一个undefined的变量a，调用后设为有值，并且判断if(!a)</li></ol><h2 id="异步的基础模式--回调callback">异步的基础模式 — 回调（callback）</h2><p>回调可以说是JavaScript的基础了，这里不讲回调的好处，只有回调的几个明显缺点（否则则么显现出后面的进化呢（笑））：</p><ol><li><p>【回调函数】回调函数封装了程序的延续（continuation）。回调函数是处理JavaScript异步逻辑最基础的方法，但也有着各种的缺点。</p></li><li><p>【嵌套回调和链式回调（回调地狱）】 有下列代码：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">//《你不知道的JavaScript（中卷）》</span>
<span class="nx">listen</span><span class="p">(</span> <span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">evt</span><span class="p">){</span>
 <span class="nx">setTimeout</span><span class="p">(</span> <span class="kd">function</span> <span class="nx">request</span><span class="p">(){</span>
     <span class="nx">ajax</span><span class="p">(</span> <span class="dl">"</span><span class="s2">http://some.url.1</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">response</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span>
         <span class="k">if</span> <span class="p">(</span><span class="nx">text</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
             <span class="nx">handler</span><span class="p">();</span>
         <span class="p">}</span>
         <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">text</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">world</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
             <span class="nx">request</span><span class="p">();</span>
         <span class="p">}</span>
     <span class="p">}</span> <span class="p">);</span>
 <span class="p">},</span> <span class="mi">500</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">);</span>
</pre></table></code></div></div><p>这是一个由三个函数嵌套在一起的链式回调，每个函数代表了一个异步序列。</p></li></ol><p>由于回调的特性，可能很难一下看出这个函数的执行逻辑（缺乏顺序性），所以又被称为回调地狱或者毁灭金字塔。</p><p>【回调地狱的缺陷】：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nx">doA</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
	<span class="nx">doC</span><span class="p">();</span>

	<span class="nx">doD</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
		<span class="nx">doF</span><span class="p">();</span>
	<span class="p">}</span> <span class="p">)</span>

	<span class="nx">doE</span><span class="p">();</span>
<span class="p">}</span> <span class="p">);</span>

<span class="nx">doB</span><span class="p">();</span>
</pre></table></code></div></div><p>如果函数A和D是异步执行的，那么这个回调过程的执行步骤是A - F - B - C - E - D</p><p>除了难以阅读以外，回调地狱真正的问题在于一旦指定了所有的可能时间和路径，代码就会变得十分复杂，无法维护和更新。因为一个进行的回调要是能够覆盖所有路径，可能会写上很多并行的回调函数，在代码中看起来可能会十分凌乱和难以调试维护。</p><ol><li>【控制反转】这牵涉到异步程序设计的信任问题。</li></ol><p>控制反转就是程序执行的主动权从自己的手中交了出去。如果仅仅是简单的ajax调用，那么这个控制切换可能不会带来什么大问题。但如果将一个回调函数交给一个外部的API，因为无法查看的具体代码，所以可以看做是一个黑箱。这个黑箱导致问题是无法调试，不知道这个外部程序到底怎样调用了这个回调函数，是一次都没有，还是调用了很多次，亦或是比预想中过早过晚的调用，最终可能的后果就是程序执行的结果不如所愿。</p><p>教科书一点的定义就是把自己程序一部分的执行控制交给了某个第三方，且与这个第三方之间没有一份明确表达的契约。</p><p>因为回调没有机制来保障这个必然出现的控制反转的问题，这就成为了回调的最大问题，会导致信任链的完全断裂，是程序出错。</p><p>回调函数必须遵守的原则就是：信任，但要核实。（Trust But Verify.）</p><ol><li><p>【error-first风格】回调函数的第一个参数留给错误处理，如果成功第一个参数就置为false，否则为true。回调执行时先进行判断。 但是这个风格并没有完全解决信任的问题，如果同时成功和失败，就要另外写代码来处理。</p></li><li><p>【Zalgo】回调会有同步回调调用和异步回调调用。这样也会产生程序的运行问题，见下列代码：</p></li></ol><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">result</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nx">ajax</span><span class="p">(</span> <span class="dl">"</span><span class="s2">..pre-cached-url..</span><span class="dl">"</span><span class="p">,</span> <span class="nx">result</span> <span class="p">);</span>
<span class="nx">a</span><span class="o">++</span><span class="p">;</span>
</pre></table></code></div></div><p>这端代码会有0（同步回调调用）还是1（异步回调调用）的结果就要看情况而定了 对于可能同步调用也可能异步调用给出的回调函数的第三方工具而言，这个信任问题是明显的。虽然可以用臃肿的附加代码来解决，但并不优雅。</p><p>这样的同步异步的混淆产生了另一条准则： 永远要异步调用回调，即使只在事件的下一轮。 （always invoke callbacks asynchronously, even if that’s “right away” on the next turn of the event loop）</p><h2 id="异步的进化一-----promise">异步的进化一 — Promise</h2><p>前面一部分已经描述到了回调函数的两个问题分别是：缺乏顺序性和缺乏可信任性。</p><p>那么这部分的Promise主要用来解决了可信任性的问题。</p><ol><li><p>【解决可信任问题的范式】不把程序的控制权交给第三方，而是希望第三方提供一个了解其任务何时结束的能力，然后由我们的代码来决定接下来做什么。</p></li><li><p>【未来值】A对于B有一个承诺，如果A给出了任务完成可以兑现承诺或者失败不能兑现承诺的值，那么这个值就称为未来值，简单而言就是要在未来才能确定的值，但有承诺保证这个值存在。</p></li></ol><p>由于未来值可能有两个可能，要么成功，要么失败。所以Promise值的then方法（在Promise值确定之后调用的函数）就可以接收两个参数，第一个为成功的话执行的函数，第二个为失败的话执行的函数。</p><p>举个例子：</p><p>把x和y相加，如果有一个值没有准备好，那就等待。一旦全部准备好就相加返回。</p><p>为了统一处理将来和现在，就把他们全部变成未来值，就全部异步调用。</p><p>回调模式下的代码：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">getX</span><span class="p">,</span><span class="nx">getY</span><span class="p">,</span><span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">;</span>
	<span class="nx">getX</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">xVal</span><span class="p">){</span>
		<span class="nx">x</span> <span class="o">=</span> <span class="nx">xVal</span><span class="p">;</span>
		<span class="c1">// both are ready?</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">y</span> <span class="o">!=</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">cb</span><span class="p">(</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="p">);</span>	<span class="c1">// send along sum</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="p">);</span>
	<span class="nx">getY</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">yVal</span><span class="p">){</span>
		<span class="nx">y</span> <span class="o">=</span> <span class="nx">yVal</span><span class="p">;</span>
		<span class="c1">// both are ready?</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!=</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">cb</span><span class="p">(</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="p">);</span>	<span class="c1">// send along sum</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// `fetchX()` and `fetchY()` are sync or async</span>
<span class="c1">// functions</span>
<span class="nx">add</span><span class="p">(</span> <span class="nx">fetchX</span><span class="p">,</span> <span class="nx">fetchY</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">sum</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">sum</span> <span class="p">);</span> <span class="c1">// that was easy, huh?</span>
<span class="p">}</span> <span class="p">);</span>
</pre></table></code></div></div><p>Promise模式下的代码：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">xPromise</span><span class="p">,</span><span class="nx">yPromise</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// `Promise.all([ .. ])` takes an array of promises,</span>
	<span class="c1">// and returns a new promise that waits on them</span>
	<span class="c1">// all to finish</span>
	<span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span> <span class="p">[</span><span class="nx">xPromise</span><span class="p">,</span> <span class="nx">yPromise</span><span class="p">]</span> <span class="p">)</span>

	<span class="c1">// when that promise is resolved, let's take the</span>
	<span class="c1">// received `X` and `Y` values and add them together.</span>
	<span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">values</span><span class="p">){</span>
		<span class="c1">// `values` is an array of the messages from the</span>
		<span class="c1">// previously resolved promises</span>
		<span class="k">return</span> <span class="nx">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">values</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// `fetchX()` and `fetchY()` return promises for</span>
<span class="c1">// their respective values, which may be ready</span>
<span class="c1">// *now* or *later*.</span>
<span class="nx">add</span><span class="p">(</span> <span class="nx">fetchX</span><span class="p">(),</span> <span class="nx">fetchY</span><span class="p">()</span> <span class="p">)</span>

<span class="c1">// we get a promise back for the sum of those</span>
<span class="c1">// two numbers.</span>
<span class="c1">// now we chain-call `then(..)` to wait for the</span>
<span class="c1">// resolution of that returned promise.</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">sum</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">sum</span> <span class="p">);</span> <span class="c1">// that was easier!</span>
<span class="p">}</span> <span class="p">);</span>
</pre></table></code></div></div><p>通过比较明显看出Promise模式的方法可以简洁的表达一些操作。</p><p>Promise封装了依赖于时间的状态（等待未来值的产生，无论是现在还是未来产生，后续的步骤都是一样的，解决了同步回调还是异步回调的问题），其本身与时间无关，所以可以按照可预测的方式组合。但Promise一旦决议，那么永远将会保持在这个状态，成为不变值，可以随时查看。</p><ol><li><p>【revealing-constructor】一种产生Promise的模式，通常格式为 new Promise (function (…){…}) ，传入的函数将会被立即执行。</p></li><li><p>【识别Promise】识别Promise是否为真正的Promise很重要。定义某种称为thenable的东西，将其定义为任何具有then(..)方法的对象和函数，任何这样的值就是Promise一致的thenable。如果Promise决议遇到了这样的thenable的值，那么就会被搁浅在这里，导致难以追踪的bug。</p></li><li><p>【Promise解决信任问题的方法】有五种回调导致的信任问题，分别来讲：</p><ul><li>调用过早： 由于一个任务有时候同步完成，有时候异步完成。如果使用回调会导致Zalgo出现，使用Promise无论是立即决议的revealing-constructor模式，还是异步执行的内容，都会基于最前面所讲的任务队列来进行异步调用，这样就解决了调用过早的问题.</li><li>调用过晚：由于同步then调用时不被允许的，所以，一个Promise被决议之后，这个Promise上所有的通过then(…)注册的回调都会下一个异步时机点一次被立即调用。任意一个都无法影响或延误对其他回调的调用（不能插队） Ex:</li></ul></li></ol><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="dl">"</span><span class="s2">C</span><span class="dl">"</span> <span class="p">);</span>
	<span class="p">}</span> <span class="p">);</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="dl">"</span><span class="s2">A</span><span class="dl">"</span> <span class="p">);</span>
<span class="p">}</span> <span class="p">);</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="dl">"</span><span class="s2">B</span><span class="dl">"</span> <span class="p">);</span>
<span class="p">}</span> <span class="p">);</span>
<span class="c1">// A B C</span>

<span class="kd">function</span> <span class="nx">runme</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resolve</span><span class="p">();</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">//0</span>
</pre></table></code></div></div><p>这里第一个function第一次注册了打印出A的then方法，打印出B的then方法，注册完毕后进行任务队列的处理，因为A先注册，所以先执行。这里又注册了一个C的then方法，虽然p已经被决议，但是并不能立即调用（不能同步调用），还是加入到任务队列的最后，不中断对B的执行。所以执行结果是A B C。</p><p>第二个是即使是p立即决议了，但是then中的内容还是被延迟到执行完所有同步内容之后运行。</p><p>但是不同Promise值的回调顺序是不可预测的，永远不要依赖于不同Promise之间的回调顺序来进行程序调度。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>* 回调未调用 ： 没有任何东西（包括JavaScript错误）可以组织Promise决议，它总会调用resolve和reject处理方法中的一个，即使是超时也有超时模式进行处理。（后续会讲到）
* 调用次数过多或过少：由于Promise只能被决议一次，注册的then只会被最多调用一次，所以过多的调用会直接无效。过少就是之前解释的回调未调用的情况。
* 未能传递参数值、环境值：任何Promise都只能有一个决议值，如果resolve(…)或者reject(…)中传递了过多的参数，那都只会采纳第一个，而忽略其他的，如果要有多个，那么就要封装到数组或者对象中传递。
* 吞掉错误或异常：如果一个Promise产生了拒绝值并且给出了理由，那么这个就会被传给拒绝回调，即使是JavaScript的异常也会这样做。这里的会产生的另一个细节就是如果发生JavaScript错误会导致的同步调用，由于Promise的特性也会将其变为异步的调用。
</pre></table></code></div></div><p>但是试想，如果在then的正确处理函数中出现了错误会发生什么？</p><p>EX：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
	<span class="nx">resolve</span><span class="p">(</span> <span class="mi">42</span> <span class="p">);</span>
<span class="p">}</span> <span class="p">);</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
	<span class="kd">function</span> <span class="nx">fulfilled</span><span class="p">(</span><span class="nx">msg</span><span class="p">){</span>
		<span class="nx">foo</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">msg</span> <span class="p">);</span>	<span class="c1">// never gets here :(</span>
	<span class="p">},</span>
	<span class="kd">function</span> <span class="nx">rejected</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
		<span class="c1">// never gets here either :(</span>
	<span class="p">}</span>
<span class="p">);</span>
</pre></table></code></div></div><p>由于第一个then中未定义bar函数，所以会产生一个错误，但是并不会立即处理，而是会产生另一个Promise，这个新的Promise会由于错误而被拒绝，并没有吞掉错误。因为p已经被决议为正确，所以不会因为fulfilled中间有错误而去调用rejected。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>* Promise.resolve()方法产生的Promise保证了返回内容的可信任性：  分别考虑resolve方法的参数，1）如果是一个非Promise，非thenable的 立即值，那么就会返回一个用这个值填充的Promise封装，保证了内容的可信任。（即使是错误值） 2）如果是一个Promise，那么也只会产生一个Promise。3）如果传递了一个thenable的非Promise，那么就会试图展开这个值，直到遇到了一个符合1条件的立即值，并封装为Promise
</pre></table></code></div></div><p>通过这个方法，可以保证异步返回给回调函数的值为Promise可信任的。</p><ol><li>【链式流】链式流可以应用在会进行多次异步调用的方法中，可以加强代码的清晰度可读性和快速定位错误。 参见下面两个代码段：</li></ol><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="c1">//来自：http://imweb.io/topic/57a0760393d9938132cc8da9</span>
<span class="nx">getUserAdmin</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="cm">/*管理员*/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">getProjectsWithAdmin</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*根据项目id，获取模块列表*/</span>
            <span class="nx">getModules</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">ids</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/*根据模块id，获取接口列表*/</span>
                <span class="nx">getInterfaces</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">ids</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// ...</span>
                <span class="p">})</span>
            <span class="p">})</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">})</span>


<span class="c1">//链式流</span>
<span class="nx">getUserAdmin</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">reult</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="cm">/*管理员*/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">getProjectsWithAdmin</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">getProjectsWithUser</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*获取project id列表*/</span>
    <span class="k">return</span> <span class="nx">getModules</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">ids</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*获取project id列表*/</span>
    <span class="k">return</span> <span class="nx">getInterfaces</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">ids</span><span class="p">)</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">})</span>
</pre></table></code></div></div><p>能够产生链式流基于以下两个Promise的特性： * 每次对Promise调用then(…)，它都会产生一个新的Promise。 * 不管从then(…)调用的完成回调（第一个参数）返回的值是什么，它都会被自动设置为被连接Promise的完成，这句话表述了这个新的Promise的值就是这个then调用方法里的return语句，如果没有，那么这个Promise的值就是undefined。 考虑以下代码：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span> <span class="mi">21</span> <span class="p">);</span>

<span class="nx">p</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">v</span> <span class="p">);</span>	<span class="c1">// 21</span>

	<span class="c1">// fulfill the chained promise with value `42`</span>
	<span class="k">return</span> <span class="nx">v</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span> <span class="p">)</span>
<span class="c1">// here's the chained promise</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">v</span> <span class="p">);</span>	<span class="c1">// 42</span>
<span class="p">}</span> <span class="p">);</span>
</pre></table></code></div></div><p>上面的代码充分展现了这两条规则。另外两条则充分说明了即使是返回一个Promise甚至返回中有异步调用（这里的异步调用不会被放入事件循环的最后，而是在这里直接延迟执行，后续的then会等待其执行完毕），这两条规则都会正常工作：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span> <span class="mi">21</span> <span class="p">);</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">v</span> <span class="p">);</span>	<span class="c1">// 21</span>

	<span class="c1">// create a promise and return it</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
		<span class="c1">// fulfill with value `42`</span>
		<span class="nx">resolve</span><span class="p">(</span> <span class="nx">v</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span>
	<span class="p">}</span> <span class="p">);</span>
<span class="p">}</span> <span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">v</span> <span class="p">);</span>	<span class="c1">// 42</span>
<span class="p">}</span> <span class="p">);</span>
</pre></table></code></div></div><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span> <span class="mi">21</span> <span class="p">);</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">v</span> <span class="p">);</span>	<span class="c1">// 21</span>

	<span class="c1">// create a promise to return</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
		<span class="c1">// introduce asynchrony!</span>
		<span class="nx">setTimeout</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
			<span class="c1">// fulfill with value `42`</span>
			<span class="nx">resolve</span><span class="p">(</span> <span class="nx">v</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span>
		<span class="p">},</span> <span class="mi">100</span> <span class="p">);</span>
	<span class="p">}</span> <span class="p">);</span>
<span class="p">}</span> <span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
	<span class="c1">// runs after the 100ms delay in the previous step</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">v</span> <span class="p">);</span>	<span class="c1">// 42</span>
<span class="p">}</span> <span class="p">);</span>
</pre></table></code></div></div><p>如果链中有步骤出错，会直接将这个错误封装为Promise传入到链中的下一个错误处理方法中（原因之前已经讲过）。如果这个错误处理return了一个值，那么这个值会被带入到下一个then处理的正确处理方法中，如果return了一个Promise那么就有可能会使得下一个then延迟调用。如果没有return，那就默认return undefined，同样也是正确处理中。</p><p>默认的拒绝处理函数：如果产生了错误，但没有拒绝处理函数，那么就会有默认的，默认的所做的事情就是抛出错误，那么这个错误就会继续向下直到有显式的拒绝处理函数。 默认的接收处理函数：纯粹将一个promise继续向下传递。如果只有拒绝处理可以将简写为：catch(function(err){…})</p><ol><li>【Promise的错误处理】 由于Promise一旦被决议就不再更改的特性，以下代码可能会导致没有错误处理函数来处理：</li></ol><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span> <span class="mi">42</span> <span class="p">);</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
	<span class="kd">function</span> <span class="nx">fulfilled</span><span class="p">(</span><span class="nx">msg</span><span class="p">){</span>
		<span class="c1">// numbers don't have string functions,</span>
		<span class="c1">// so will throw an error</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()</span> <span class="p">);</span>
	<span class="p">},</span>
	<span class="kd">function</span> <span class="nx">rejected</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
		<span class="c1">// never gets here</span>
	<span class="p">}</span>
<span class="p">);</span>
</pre></table></code></div></div><p>几种解决方案（除了1都未被ES6标准实现）： 1） 在最后加catch，这样会导致的问题就是catch中的函数如果也有错误就无法捕捉。 2）有个done函数，就算done函数有错误，也传入done中。</p><ol><li>【Promise模式】之前介绍了两种并发的模式，这里有Promise来直接实现： 1） 门：几个均实现再继续进行： Promise.all([….])，参数可以是由立即值，thenable或者Promise组成的数组。 注意：如果传入空数组，那么接下来的内容就会被立即设定为完成。如果有Promise.all中有任意一个被拒绝，那么整个都被拒绝，进入到拒绝处理函数。这个模式传入到完成处理函数中的参数是一个数组，数组中的顺序与all中声明的顺序相同，与其产生的顺序无关。 2） 竞态：几个中只有一个能执行：Promise.race([…])，参数与all相同，但是如果是立即值的竞争那就会显得毫无意义，第一个立即值会胜出。 注意：一旦有一个Promise被完成，那就全部完成，如果第一个是拒绝，那么整个都被拒绝。如果传递空数组，那么Promise会永远都不会被决议。 3）超时模式的实现：之前讲到了会有超时模式，这里利用竞态可以来实现：</li></ol><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// `foo()` is a Promise-aware function</span>

<span class="c1">// `timeoutPromise(..)`, defined ealier, returns</span>
<span class="c1">// a Promise that rejects after a specified delay</span>

<span class="c1">// setup a timeout for `foo()`</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">(</span> <span class="p">[</span>
	<span class="nx">foo</span><span class="p">(),</span>					<span class="c1">// attempt `foo()`</span>
	<span class="nx">timeoutPromise</span><span class="p">(</span> <span class="mi">3000</span> <span class="p">)</span>	<span class="c1">// give it 3 seconds</span>
<span class="p">]</span> <span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span>
	<span class="kd">function</span><span class="p">(){</span>
		<span class="c1">// `foo(..)` fulfilled in time!</span>
	<span class="p">},</span>
	<span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
		<span class="c1">// either `foo()` rejected, or it just</span>
		<span class="c1">// didn't finish in time, so inspect</span>
		<span class="c1">// `err` to know which</span>
	<span class="p">}</span>
<span class="p">);</span>
</pre></table></code></div></div><p>4）几种变体： none：所有的Promise都是拒绝才是完成 any：只要有一个完成就是完成 first：只要第一个Promise完成，那么整个就是完成 last：只有最后一个完成胜出</p><ol><li>【Promise的问题】讲了那么多好处。。Promise当然也有问题： 1） 顺序错误处理：可能会有错误被忽略而被全局抛出 2）单一值：只能有一个完成值、拒绝值，否则只能封装解封，这样会显得有些笨重。（这个问题可以通过ES6中的…运算来方便处理~） 3) 单决议：如果讲一个决议绑定到会重复进行的操作上，那么这个决议只会记住重复操作的第一次结果，如：</li></ol><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// `click(..)` binds the `"click"` event to a DOM element</span>
<span class="c1">// `request(..)` is the previously defined Promise-aware Ajax</span>

<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
	<span class="nx">click</span><span class="p">(</span> <span class="dl">"</span><span class="s2">#mybtn</span><span class="dl">"</span><span class="p">,</span> <span class="nx">resolve</span> <span class="p">);</span>
<span class="p">}</span> <span class="p">);</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">evt</span><span class="p">){</span>
	<span class="kd">var</span> <span class="nx">btnID</span> <span class="o">=</span> <span class="nx">evt</span><span class="p">.</span><span class="nx">currentTarget</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
	<span class="k">return</span> <span class="nx">request</span><span class="p">(</span> <span class="dl">"</span><span class="s2">http://some.url.1/?id=</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">btnID</span> <span class="p">);</span>
<span class="p">}</span> <span class="p">)</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">text</span> <span class="p">);</span>
<span class="p">}</span> <span class="p">);</span>
<span class="c1">//第二次按下就不会有任何操作，不会再次执行resolve</span>
</pre></table></code></div></div><p>4） 惯性：已经有很多回调的代码不会自然的进行Promise改写 5）无法取消：如果Promise因为某些原因悬而未决的话，无法从外部阻止其继续执行。 6）Promise会对性能有稍稍影响，但总体功大于过。</p></div><div class="post-tail-wrapper text-muted" id="post-tail-wrapper"><div class="pt-3"> <a href="/tags/javascript/" class="post-tag no-text-decoration" >javascript</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" class="post-tag no-text-decoration" >前端</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" class="post-tag no-text-decoration" >异步</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center pt-5 pb-2"><div class="license-wrapper"> <span class="license-text ml-1 mr-1"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 <i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> </a> </span></div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label ml-1 mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=JavaScript精进之路 — 异步的实现（上） - Subaru&url=https://mq-380.github.io/posts/js2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=JavaScript精进之路 — 异步的实现（上） - Subaru&u=https://mq-380.github.io/posts/js2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=JavaScript精进之路 — 异步的实现（上） - Subaru&url=https://mq-380.github.io/posts/js2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/huzhiqiang/">世界在年轻的胸怀（胡志强） </a></li><li><a href="/posts/Calc/">计算几何专题练习</a></li><li><a href="/posts/People/">独树一帜的「民主」</a></li><li><a href="/posts/algotree/">基础算法与数据结构（二） 树（1）基础二叉树</a></li><li><a href="/posts/tuopu/">基础算法与数据结构（七） 拓扑排序</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <!-- The trending tags list v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung MIT Licensed --> <a class="post-tag" href="/tags/图/">图</a> <a class="post-tag" href="/tags/前端/">前端</a> <a class="post-tag" href="/tags/新年/">新年</a> <a class="post-tag" href="/tags/年终/">年终</a> <a class="post-tag" href="/tags/近代中国/">近代中国</a> <a class="post-tag" href="/tags/读书/">读书</a> <a class="post-tag" href="/tags/历史/">历史</a> <a class="post-tag" href="/tags/树/">树</a> <a class="post-tag" href="/tags/操作系统/">操作系统</a> <a class="post-tag" href="/tags/其他/">其他</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-3">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="post-extend-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/js1/" class="btn btn-outline-primary"><p>JavaScript精进之路 — 函数、闭包与原型链</p></a> <a href="/posts/os2/" class="btn btn-outline-primary"><p>操作系统复习（二） 线程</p></a></div><!-- The related posts of current post. Placed in the bottom of every single post. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-4 mb-2 mb-sm-4 pb-2"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/videotag/"><div class="card-body"> <span class="timeago small"> May 10, 2020 <i class="unloaded">2020-05-10T20:12:36+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>关于video元素的种种</h3><div class="text-muted small"><p>看起来已经很久没有写技术方面的文章了，今天就来记录一下最近经常打交道的一个html元素——video。 说起video元素，是html5中新加入标准的“新兴”元素，基本目的是用来取代flash插件，以弥补html中关于多媒体的弱项。（一起被带入的当然audio元素）。 P.S 经过了那么多年，Chrome似乎终于会在这几年不再支持flash。。 不过，新元素总不是那么的完美。各个浏览器...</p></div></div></a></div><div class="card"> <a href="/posts/design/"><div class="card-body"> <span class="timeago small"> Jul 16, 2017 <i class="unloaded">2017-07-16T00:03:36+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>课程设计前端踩坑记录</h3><div class="text-muted small"><p>使用vue框架完成这个课程设计（第一次使用）已经完成了好长时间了，总结了一下使用框架的10条踩坑经验。 （这个老师的课就是个坑，给分超低。） 课程设计的代码全部保存在github上，地址：GitHub - MQ-380/Manager: First try on Vue （webproject为所有前端部分） 数据的保存与传输 localstorage和sessionst...</p></div></div></a></div><div class="card"> <a href="/posts/js1/"><div class="card-body"> <span class="timeago small"> Aug 10, 2017 <i class="unloaded">2017-08-10T00:03:36+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JavaScript精进之路 — 函数、闭包与原型链</h3><div class="text-muted small"><p>开这个专题，说实话，就是为了准备校招，补补基础知识吧。 今天这个话题是因为这几天看了《JavaScript忍者秘籍》，感觉这本书把这几个内容讲的蛮透彻了，特撰本文，以便日后翻阅。（应该都会以知识点的形式给出吧。） 函数 【基本类型】JavaScript中函数为first-class object，typeof的结果是object，没有function这个基本类型，但有可以...</p></div></div></a></div></div></div></div></div></div><script> document.addEventListener('scroll', function(){ let wrapperHeight = $('#post-wrapper').height() - $('#post-tail-wrapper').height(); let nowPosition = $(document).scrollTop(); let now = wrapperHeight !== 0 ? nowPosition / wrapperHeight : 0; $('#progress').attr('style', `width: ${(now * 100)}%`); }); </script> <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const observer = lozad(); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2020 <a href="https://twitter.com/mq380">MAO</a>. <span data-toggle="tooltip" data-placement="top" title="The blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with theme <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a>.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted">Trending Tags</h4><!-- The trending tags list v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung MIT Licensed --> <a class="post-tag" href="/tags/图/">图</a> <a class="post-tag" href="/tags/前端/">前端</a> <a class="post-tag" href="/tags/新年/">新年</a> <a class="post-tag" href="/tags/年终/">年终</a> <a class="post-tag" href="/tags/近代中国/">近代中国</a> <a class="post-tag" href="/tags/读书/">读书</a> <a class="post-tag" href="/tags/历史/">历史</a> <a class="post-tag" href="/tags/树/">树</a> <a class="post-tag" href="/tags/操作系统/">操作系统</a> <a class="post-tag" href="/tags/其他/">其他</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-74221043-1', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js" integrity="sha256-qcLR00zq6pJk4je3MLgAri8Nn+ZumUlXgTKR2H/xCY0=" crossorigin="anonymous"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://mq-380.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
